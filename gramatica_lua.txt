
Block => (Stmt;)*

Stmt => Vars = Exps
    |   Function
    |   do Block end
    |   while Exp do BLock end
    |   if Exp then Block (elseif Exp then Block)* (else Block)opt end
    |   return Exps opt
    |   break
    |   for Stmt1
    |   local Stmt2


Stmt1 => Name = Exp , Exp (, Exp)opt do Block end
    |    Names in Exps do Block end

Stmt2 =>
    |   opt function Name FunctionBody
    |   Names = Exps

Exps => Exp (,Exp)*

Exp => not Exp
    |   - Exp
    |   PrefixExp
    |   Function
    |   {(Field(, Field)*)opt}
    |   nil
    |   true
    |   false
    |   Number
    |   String

    |   not Exp Exp'
    |   - Exp Exp'
    |   PrefixExp Exp'
    |   Function Exp'
    |   {(Field(, Field)*)opt} Exp'
    |   nil Exp'
    |   true Exp'
    |   false Exp'
    |   Number Exp'
    |   String Exp'

Exp' => BinOp Exp
    |   BinOp Exp Exp' 

PrefixExp => Name
    |   (Exp)
    |   Name PrefixExp'
    |   (Exp) PrefixExp'

PrefixExp' =>  [Exp]
    | [Exp] PrefixExp'



Field => [Epx] = Exp               
    |   Name = Exp

BinOp => or 
    | and 
    | < BinOp'
    | > BinOp'
    | ~= 
    | == 
    | . . 
    | + 
    | - 
    | * 
    | / 
    | ^ 

BinOp' => = | ""    

Vars => Var (,Var)*

Var => Name
    |   PrefixExp [Exp]

Function => FunctionBody
    |   FunctionBody Function


FunctionBody => Name (Params opt) Block end

Params => Names

Names => Name (, Name)*